#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint n_rows;      // Number of rows to process
    uint row_size;    // Elements per row
} pc;

layout(std430, binding = 0) buffer MapBuffer {
    float data[];
};

layout(std430, binding = 1) buffer SrcLocs {
    uint locs_src[];  // Start of each row
};

layout(std430, binding = 2) buffer DstLocs {
    uint locs_dst[];  // Start of each output row
};

shared float sdata[256];

void main() {
    uint tid = gl_LocalInvocationID.x;
    uint row_idx = gl_WorkGroupID.x;
    
    if (row_idx >= pc.n_rows) return;
    
    uint src_base = locs_src[row_idx];
    uint dst_base = locs_dst[row_idx];
    
    // Step 1: Find max (parallel reduction)
    float max_val = -1e38;
    for (uint i = tid; i < pc.row_size; i += 256) {
        max_val = max(max_val, data[src_base + i]);
    }
    sdata[tid] = max_val;
    barrier();
    
    for (uint s = 128; s > 0; s >>= 1) {
        if (tid < s) sdata[tid] = max(sdata[tid], sdata[tid + s]);
        barrier();
    }
    float row_max = sdata[0];
    barrier();
    
    // Step 2: Compute exp(x - max) and sum
    float sum_val = 0.0;
    for (uint i = tid; i < pc.row_size; i += 256) {
        float e = exp(data[src_base + i] - row_max);
        data[dst_base + i] = e;  // Store exp temporarily
        sum_val += e;
    }
    sdata[tid] = sum_val;
    barrier();
    
    for (uint s = 128; s > 0; s >>= 1) {
        if (tid < s) sdata[tid] += sdata[tid + s];
        barrier();
    }
    float row_sum = sdata[0];
    barrier();
    
    // Step 3: Normalize
    float inv_sum = 1.0 / row_sum;
    for (uint i = tid; i < pc.row_size; i += 256) {
        data[dst_base + i] *= inv_sum;
    }
}
