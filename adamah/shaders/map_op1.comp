#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint op_code;
    uint n_locs;        // Number of locations to process
    uint pack_size;     // Elements per pack
} pc;

// Map data buffer
layout(std430, binding = 0) buffer MapBuffer {
    float map_data[];
};

// Source locations
layout(std430, binding = 1) buffer SrcLocs {
    uint locs_src[];
};

// Destination locations
layout(std430, binding = 2) buffer DstLocs {
    uint locs_dst[];
};

void main() {
    uint tid = gl_GlobalInvocationID.x;
    
    // Each thread handles one element across all packs
    // tid = loc_idx * pack_size + elem_idx
    uint loc_idx = tid / pc.pack_size;
    uint elem_idx = tid % pc.pack_size;
    
    if (loc_idx >= pc.n_locs) return;
    
    // Source and destination offsets in map
    uint src_offset = locs_src[loc_idx] * pc.pack_size + elem_idx;
    uint dst_offset = locs_dst[loc_idx] * pc.pack_size + elem_idx;
    
    float val = map_data[src_offset];
    float result;
    
    switch (pc.op_code) {
        case 0:  result = -val; break;                    // NEG
        case 1:  result = abs(val); break;                // ABS
        case 2:  result = sqrt(val); break;               // SQRT
        case 3:  result = exp(val); break;                // EXP
        case 4:  result = log(val); break;                // LOG
        case 5:  result = tanh(val); break;               // TANH
        case 6:  result = max(0.0, val); break;           // RELU
        case 7:  // GELU
            result = 0.5 * val * (1.0 + tanh(0.7978845608 * (val + 0.044715 * val * val * val)));
            break;
        case 8:  result = sin(val); break;                // SIN
        case 9:  result = cos(val); break;                // COS
        
        // Trigonometric (native GLSL)
        case 10: result = tan(val); break;                // TAN
        case 11: result = asin(val); break;               // ASIN
        case 12: result = acos(val); break;               // ACOS
        case 13: result = atan(val); break;               // ATAN
        case 14: result = sinh(val); break;               // SINH
        case 15: result = cosh(val); break;               // COSH
        
        // Activations (ML)
        case 16: // SIGMOID = 1 / (1 + exp(-x))
            result = 1.0 / (1.0 + exp(-val));
            break;
        case 17: // SWISH = x * sigmoid(x)
            result = val / (1.0 + exp(-val));
            break;
        case 18: { // MISH = x * tanh(softplus(x)) = x * tanh(ln(1 + exp(x)))
            float sp = log(1.0 + exp(val));
            result = val * tanh(sp);
            break;
        }
        case 19: { // SELU = 1.0507 * (x > 0 ? x : 1.67326 * (exp(x) - 1))
            result = val > 0.0 ? val : 1.67326 * (exp(val) - 1.0);
            result *= 1.0507;
            break;
        }
        case 20: { // ELU = x > 0 ? x : alpha * (exp(x) - 1)
            const float alpha = 1.0;
            result = val > 0.0 ? val : alpha * (exp(val) - 1.0);
            break;
        }
        case 21: // LEAKY_RELU = max(x, 0.01*x)
            result = max(val, 0.01 * val);
            break;
        
        // Mathematical
        case 22: result = ceil(val); break;               // CEIL
        case 23: result = floor(val); break;              // FLOOR
        case 24: result = round(val); break;              // ROUND
        case 25: // SIGN = -1, 0, or +1
            result = val > 0.0 ? 1.0 : (val < 0.0 ? -1.0 : 0.0);
            break;
        case 26: result = 1.0 / val; break;               // RECIPROCAL
        case 27: result = val * val; break;               // SQUARE
        case 28: result = val * val * val; break;         // CUBE
        case 29: result = log(1.0 + exp(val)); break;    // SOFTPLUS
        case 30: // HARDSIGMOID = clamp(0.2*x + 0.5, 0, 1)
            result = clamp(0.2 * val + 0.5, 0.0, 1.0);
            break;
        case 31: // HARDSWISH = x * hardsigmoid(x)
            result = val * clamp(0.2 * val + 0.5, 0.0, 1.0);
            break;
        case 32: result = exp(val) - 1.0; break;          // EXPM1
        case 33: result = log(1.0 + val); break;          // LOG1P
        
        default: result = val; break;
    }
    
    map_data[dst_offset] = result;
}
