#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint n_rows;      // Number of vectors to normalize
    uint dim;         // Dimension of each vector
    float eps;        // Epsilon for numerical stability
} pc;

layout(std430, binding = 0) buffer MapBuffer {
    float data[];
};

layout(std430, binding = 1) buffer SrcLocs {
    uint locs_src[];  // Start of each input vector
};

layout(std430, binding = 2) buffer DstLocs {
    uint locs_dst[];  // Start of each output vector
};

layout(std430, binding = 3) buffer GammaLocs {
    uint locs_gamma[];  // Gamma weights (one per row, or single shared)
};

layout(std430, binding = 4) buffer BetaLocs {
    uint locs_beta[];   // Beta weights
};

shared float sdata[256];
shared float sdata2[256];

void main() {
    uint tid = gl_LocalInvocationID.x;
    uint row_idx = gl_WorkGroupID.x;
    
    if (row_idx >= pc.n_rows) return;
    
    uint src_base = locs_src[row_idx];
    uint dst_base = locs_dst[row_idx];
    uint gamma_base = locs_gamma[row_idx];
    uint beta_base = locs_beta[row_idx];
    
    // Step 1: Compute mean
    float sum_val = 0.0;
    for (uint i = tid; i < pc.dim; i += 256) {
        sum_val += data[src_base + i];
    }
    sdata[tid] = sum_val;
    barrier();
    
    for (uint s = 128; s > 0; s >>= 1) {
        if (tid < s) sdata[tid] += sdata[tid + s];
        barrier();
    }
    float mean = sdata[0] / float(pc.dim);
    barrier();
    
    // Step 2: Compute variance
    float var_sum = 0.0;
    for (uint i = tid; i < pc.dim; i += 256) {
        float diff = data[src_base + i] - mean;
        var_sum += diff * diff;
    }
    sdata[tid] = var_sum;
    barrier();
    
    for (uint s = 128; s > 0; s >>= 1) {
        if (tid < s) sdata[tid] += sdata[tid + s];
        barrier();
    }
    float variance = sdata[0] / float(pc.dim);
    float inv_std = 1.0 / sqrt(variance + pc.eps);
    barrier();
    
    // Step 3: Normalize and apply gamma/beta
    for (uint i = tid; i < pc.dim; i += 256) {
        float x_norm = (data[src_base + i] - mean) * inv_std;
        float gamma = data[gamma_base + i];
        float beta = data[beta_base + i];
        data[dst_base + i] = gamma * x_norm + beta;
    }
}
