#version 450

layout(local_size_x = 256) in;

layout(push_constant) uniform PushConstants {
    uint op_code;
    uint n_locs;        // Number of locations to process
    uint pack_size;     // Elements per pack
} pc;

// Map data buffer
layout(std430, binding = 0) buffer MapBuffer {
    float map_data[];
};

// Source locations
layout(std430, binding = 1) buffer SrcLocs {
    uint locs_src[];
};

// Destination locations
layout(std430, binding = 2) buffer DstLocs {
    uint locs_dst[];
};

void main() {
    uint tid = gl_GlobalInvocationID.x;
    
    // Each thread handles one element across all packs
    // tid = loc_idx * pack_size + elem_idx
    uint loc_idx = tid / pc.pack_size;
    uint elem_idx = tid % pc.pack_size;
    
    if (loc_idx >= pc.n_locs) return;
    
    // Source and destination offsets in map
    uint src_offset = locs_src[loc_idx] * pc.pack_size + elem_idx;
    uint dst_offset = locs_dst[loc_idx] * pc.pack_size + elem_idx;
    
    float val = map_data[src_offset];
    float result;
    
    switch (pc.op_code) {
        case 0:  result = -val; break;                    // NEG
        case 1:  result = abs(val); break;                // ABS
        case 2:  result = sqrt(val); break;               // SQRT
        case 3:  result = exp(val); break;                // EXP
        case 4:  result = log(val); break;                // LOG
        case 5:  result = tanh(val); break;               // TANH
        case 6:  result = max(0.0, val); break;           // RELU
        case 7:  // GELU
            result = 0.5 * val * (1.0 + tanh(0.7978845608 * (val + 0.044715 * val * val * val)));
            break;
        case 8:  result = sin(val); break;                // SIN
        case 9:  result = cos(val); break;                // COS
        case 10: result = 1.0 / val; break;               // RECIP
        case 11: result = val * val; break;               // SQR
        default: result = val; break;
    }
    
    map_data[dst_offset] = result;
}
